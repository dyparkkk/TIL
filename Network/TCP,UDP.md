# TCP,UDP

## IP 프로토콜의 한계

- 비연결성 - 패킷 받을 대상이 없거나 서비스 불능 상태여도 전송
- 비신뢰성 - 중간에 패킷이 사라짐, 패킷 순서를 보장하지 않음
- 프로그램 구분 - 같은 ip여도 어플리케이션이 여러 개 동작중

## TCP

- **전송 계층(전송 제어)에서 신뢰성을 보장하는 연결형 프로토콜**
- 전송 제어, 순서, 검증 정보 등 ip 계층보다 추가로 제공
- header : 송수신자 포트번호, 시퀀스 번호, ack번호, 데이터 오프셋(tcp 세그먼트 관련), 윈도우크기(수신 윈도우의 버퍼 크기, 0이면 전송 중지), 제어비트 등
    - 연결형 서비스  : 가상 회선방식 사용 , 3handShake
    - 흐름제어 : 데이터 속도 조절해서 수신자의 버퍼 오버플로우 방지
    - 혼잡제어 : 네트워크 내의 패킷 수 넘치지 않게 방지
        - 보내는 쪽에서 ack로 네트워크 혼잡 상황을 유추해서 네트워크가 수용할 수 있는 만큼 보냄
- 신뢰성 높은 전송 : ack 값 연속으로 유지, 중복시 재전송 요청
- 점대점(Point to Point), 전이중(full-duplex) 방식

## 3way handShake

1. 먼저 open()을 실행한 클라이언트가 `SYN`을 보내고 `SYN_SENT` 상태로 대기한다.
2. 서버는 `SYN_RCVD` 상태로 바꾸고 `SYN`과 응답 `ACK`를 보낸다.
3. `SYN`과 응답 `ACK`을 받은 클라이언트는 `ESTABLISHED` 상태로 변경하고 서버에게 응답 `ACK`를 보낸다.
4. 응답 `ACK`를 받은 서버는 `ESTABLISHED` 상태로 변경한다.

## 4way handShake

1. 먼저 close()를 실행한 클라이언트가 FIN을 보내고 `FIN_WAIT1` 상태로 대기한다.
2. 서버는 `CLOSE_WAIT`으로 바꾸고 응답 ACK를 전달한다. 동시에 해당 포트에 연결되어 있는 어플리케이션에게 close()를 요청한다.
3. ACK를 받은 클라이언트는 상태를 `FIN_WAIT2`로 변경한다.
4. close() 요청을 받은 서버 어플리케이션은 종료 프로세스를 진행하고 `FIN`을 클라이언트에 보내 `LAST_ACK` 상태로 바꾼다.
5. FIN을 받은 클라이언트는 ACK를 서버에 다시 전송하고 `TIME_WAIT`으로 상태를 바꾼다. `TIME_WAIT`에서 일정 시간이 지나면 `CLOSED`된다. ACK를 받은 서버도 포트를 `CLOSED`로 닫는다.

# UDP

header : **송수신자 포트번호, 데이터 길이, checksum**  ... 끝

- 하얀 도화지와 같음 (기능이 거의 없음) → 최적화가 가능하다 !!
- 수신자가 받는지 마는지 관심없음 → 신뢰성 보장 x
- 데이터 경계를 구분 → Datagram Service
- 데이터 재전송 없음

### http/3는 왜 UDP를 선택했을까?

- TCP의 3way-handshake도 최적화 하자 !!
- 참고자료 : [https://evan-moon.github.io/2019/10/08/what-is-http3/](https://evan-moon.github.io/2019/10/08/what-is-http3/)